namespace lsst { namespace pipe { namespace base {

/**
\mainpage lsst::pipe::base; Base package for pipeline tasks

\section pipeBase_introduction Introduction

lsst::pipe::base offers infrastructure to support data processing pipeline tasks.

The basic design is as follows:
- The LSST equivalent of a data processing pipeline is a pipeline task,
  also called a "command-line task". This is a subclass of
  \ref cmdLineTask.CmdLineTask "CmdLineTask". A command-line task
  is launched from the command line, and it may call other tasks (subtasks) to perform
  to perform part of the processing.

- Each task may call subtasks (instances of \ref task.Task "Task" or
  \ref cmdLineTask.CmdLineTask "CmdLineTask") as it sees fit.
  These calls are made as ordinary method calls on the subtask.

- Each task is configured using a task-specific subclass of pex.config.Config.
  The configuration includes all subtasks that the task may call. As a result, it is easy to replace
  (or "retarget") one subtask with another. A common use for this is to provide a
  camera-specific variant of a particular task, e.g. one version for SDSS image data,
  another version for Hyper Superime-Cam data).

- Most tasks have a run method that performs the primary data processing.
  - The run method for a subclass of \ref cmdLineTask.CmdLineTask "CmdLineTask"
    typically receives a single butler data reference. If your task's run method needs something else
    (for instance a coaddition task's run method would need a set of images to coadd)
    then you can override the task's \ref cmdLineTask.TaskRunner "task runner" to change this.
  - Subclasses of \ref task.Task "Task" usually also have a run method,
    but it can use any arguments deemed appropriate.
  - Each task's run method should return a \ref struct.Struct "Struct"; this allows named
    access to returned data, which provides safer evolution than relying on the order of returned values.
    Any other task methods that return more than one or two items of data should also return 
    the data in a \ref struct.Struct "Struct".
  
- Many tasks are found in the pipe_tasks package, especially tasks that use many packages and don't seem to
  belong in any one of them. Tasks that seem associated with a particular package should be in that package
  (for instance the ISR task is in ip_isr).

- Command-line tasks (subclasses of \ref cmdLineTask.CmdLineTask "CmdLineTask") have a
  short script in the bin directory.
  
- Pipeline tasks may process multiple data IDs in parallel, using the multiprocessing library.
  Support for this is built into the \ref argumentParser.ArgumentParser "ArgumentParser"
  and \ref cmdLineTask.TaskRunner "TaskRunner".

pipe_base is written purely in Python. The most important contents are:
- \ref cmdLineTask.CmdLineTask "CmdLineTask": base class for pipeline tasks that can be run
  from the command line.
- \ref task.Task "Task": base class for subtasks that are not meant to be run from the
  command line.
- \ref struct.Struct "Struct": object returned by the run method of a task.
- \ref argumentParser.ArgumentParser "ArgumentParser": command line parser for pipeline tasks.
- \ref timer.timeMethod "timeMethod": decorator to log performance information for a
  \ref task.Task "Task" method.
- \ref cmdLineTask.TaskRunner "TaskRunner": a class that runs command-line tasks,
    using multiprocessing when requested. This will work "as is" for most command-line tasks,
    but will need to be be subclassed if, for instance, the task's run method needs something
    other than a single data reference.

\section pipeBase_argumentParser Argument Parser Hints

Command-line tasks support <code>--help</code>.

The first argument to a task must be the path to the input repository (or --help). For example:
- <code>myTask path/to/input --id...</code> # valid: input path is the first argument
- <code>myTask --id ... path/to/input</code> # INVALID: an option comes before the input path

To shorten input, calib and output paths see \ref pipeBase_environmentVariables.

Data is specified as <code>key=value</code> pairs for one of the data identifier arguments (typically
ending in "Id"; when there is only one, it will typically be called <code>--id</code>); for details
see \ref pipeBase_argumentParser_dataIDs .  If there is more than one data identifer argument, then the
data identifiers are by default handled independently.

You may show the config, subtasks and/or data using <code>--show</code>. By default --show quits
after printing the information, but <code>--show run</code> allows the task to run. For example:
- <code>--show config data tasks</code> shows the config, data and subtasks, and then quits.
- <code>--show tasks run</code> show the subtasks and then runs the task.

For long or repetitive command lines you may wish to specify some arguments in separate text files.
See \ref pipeBase_argumentParser_argumentFiles for details.

\subsection pipeBase_argumentParser_dataIDs Specifying Data IDs

The data identifier arguments are used to specify IDs for input and output data. The ID keys depend
on the camera and on the data product in question. For example for lsstSim, calibrated exposures
are identified by the following keys: <code>visit</code>, <code>filter</code>,
<code>raft</code> and <code>sensor</code> (and a given visit has exactly one filter).

Omit a key to specify all values of that key. For example:
- <code>--id visit=54123</code> specifies all rafts and sensors for visit 54123 (and all filters,
  but there is just one filter per visit).
- <code>--id visit=54123 raft=1,0</code> specifies all sensors for visit raft 1,0 of visit 54123

To specify multiple data IDs you may separate values with ^ (a character that does not have special meaning to
the unix command parser). The result is the outer product (all possible combinations). For example:
- <code>--id visit=54123^55523 raft=1,1^2,1</code> specifies four IDs: visits 54123 and 55523 of
  rafts 1,1 and 2,1

By default (but depending on the application), you may specify a data identifier argument
as many times as you like. Each one is treated independently.
Thus the following example specifies all sensors for four combinations of visit and raft,
plus all sensors for one raft of two other visits:
- <code>--id visit=54123^55523 raft=1,1^2,1 --id visit=623459^293423 raft=0,0</code>

\subsection pipeBase_argumentParser_argumentFiles Argument Files

You may specify long or repetitive command-line arguments in text files and reference those files
using @@path.

The contents of the files are identical to the command line, except that long lines
must not have a \\ continuation character. For example if the file <code>foo</code> contains:
<pre>
    --id visit=54123^55523 raft=1,1^2,1
    --config someParam=someValue --configfile configOverrideFilePath
</pre>

you can then reference it with <code>@@foo</code> and mix that with other command-line arguments
(including <code>--id</code> and <code>--config</code>):
<pre>
myTask.py inputPath @@foo --config anotherParam=anotherValue --output outputPath
</pre>

\subsection pipeBase_argumentParser_configOverride Overriding Config

The argument parser automatically loads specific config override files based on
the camera name and its obs package. See \ref pipeBase_configOverrideFiles.

In addition, you can specify config override files on the command line using --configfile
and override some (but not all) config parameters by specifying values on the command line using --config.

Examples:
- <code>--config str1=foo str2="fancier string" int1=5 intList=2,4,-87 float1=1.53 floatList=3.14,-5.6e7</code>
- <code>--configfile %config.py # where %config.py contains root.strList = "first string", "second string"</code>

There are important limitations on using <code>--config</code>; use a config override file to get around these issues:
- For items in registries you can only specify values for the active (current) item
- You cannot specify values for lists of strings
- You cannot specify a subset of list; you must specify all values at once

\section pipeBase_environmentVariables Environment Variables

The command parser uses environment variables PIPE_INPUT_ROOT, PIPE_CALIB_ROOT, and PIPE_OUTPUT_ROOT,
if available, to make it easier to specify the input, calib and output data repositories.
Each environment variable is used as a root directory for relative paths and ignored for absolute paths.
The default value for each of these environment variables is the current working directory. For example:
- mytask foo # use $PIPE_INPUT_ROOT/foo as the input repository (or ./foo if $PIPE_INPUT_ROOT is undefined)
- mytask  . # use $PIPE_INPUT_ROOT (= $PIPE_INPUT_ROOT/.) as the input repository
- mytask  /a/b # use /a/b as the input repository ($PIPE_INPUT_ROOT is ignored for absolute paths)

\section pipeBase_configOverrideFiles Automatically Loaded Config Override Files

When a pipeline task is run, two camera-specific configuration overrides are loaded, if found;
first one for the obs package then one for the camera. (There are two because in some cases
an obs package may contain data for multiple cameras). These files may override configuration
parameters or even replace subtasks with camera-specific variants (e.g. for instrument
signature removal). The configuration override files are, in order:
- <em>obs_path</em>/config/<em>task_name</em>.py
- <em>obs_path</em>/config/<em>camera_name</em>/<em>task_name</em>.py

where the path elements are:
- <em>task_name</em>: the name of the pipeline task, e.g. "processCcd"
- <em>camera_name</em>: the name of the camera, e.g. "lsstSim"
- <em>obs_path</em>: the path to the obs package for the camera, e.g. "obs_lsstSim"
*/
}}} // namespace lsst::pipe::base
