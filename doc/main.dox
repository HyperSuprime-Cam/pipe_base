/**
\mainpage lsst::pipe::base; Base package for pipeline tasks

\section pipeBase_introduction Introduction

Infrastructure to support pipeline tasks

The basic design is as follows:
- Data is processed by a pipeline task, which is usually a subclass of CmdLineTask.
  This is done by calling the parseAndRun method of the task, which parses command-line arguments
  and executes the parsed command. parseAndRun also persists the configuration used for the task,
  and metadata generated by the task (including timing data).
  
- Pipeline tasks rarely, if ever, perform multitasking (though they may well use GPUs).
  For multitasking, run multiple instances of the task.

- Each task may call subtasks (instances of Task or CmdLineTask) as it sees fit.
  Data is passed between a parent task and its subtasks by subroutine calls.

- Most tasks have a run method that performs the primary data processing.
  The run method for a subclass of CmdLineTask typically receives a single butler data reference,
  but subtasks may use any arguments they wish. Each task's run method returns a pipe_base Struct;
  this allows named access to returned data, which provides safer evolution
  than relying on the order of returned values.
  
- Some useful general tasks are found in the pipe_tasks package, in the python directory.
  Tasks meant to be run from the command line (subclasses of CmdLineTask) also have
  a short script in the bin directory.
  Package-specific tasks belong in the relevant package, e.g. ip_isr has an IsrTask.

pipe_base is written purely in Python. Contents include:
- lsst.pipe.base.CmdLineTask: base class for pipeline tasks that can be run from the command line.
- lsst.pipe.base.Task: base class for subtasks that are not meant to be run from the command line.
- lsst.pipe.base.Struct: object returned by the run method of a task.
- lsst.pipe.base.ArgumentParser: command line parser for pipeline tasks.
- lsst.pipe.base.timeMethod: decorator to log performance information about a Task method.

\section pipeBase_argumentParser Argument Parser Hints

The first argument to a task must be the path to the input repository. For example:
- <code>myTask path/to/input ...options...</code>

The one exception is <code>--help</code>, which needs no input path.
To shorten input, calib and output paths see \ref pipeBase_environmentVariables.

Specify input data using <code>--id</code>; for details see \ref pipeBase_argumentParser_dataIDs

You may show the config and/or data using <code>--show</code>. For example: <code>--show config data exit</code>
will show the config and the data and then exit without running the task.

For long or repetetive command lines you may wish to specify some arguments in separate text files.
See \ref pipeBase_argumentParser_argumentFiles for details.

\subsection pipeBase_argumentParser_dataIDs Specifying Data IDs

The <code>--id</code> argument is used to specify IDs for input data. The ID keys depend on the camera;
for <code>lsstSim</code> the valid keys are: <code>visit</code>, <code>filter</code>,
<code>raft</code> and <code>sensor</code> (and a given visit has exactly one filter).

Omit a key to specify all values of that key. For example:
- <code>--id visit=54123</code> specifies all rafts and sensors for visit 54123 (and all filters, but there is just one filter per visit).
- <code>--id visit=54123 raft=1,0</code> specifies all sensors for visit raft 1,0 of visit 54123

To specify multiple data IDs you may separate values with ^ (a character that does not have special meaning to
the unix command parser). The result is the outer product (all possible combinations). For example:
- <code>--id visit=54123^55523 raft=1,1^2,1</code> specifies four IDs: visits 54123 and 55523 of rafts 1,1 and 2,1

You may specify the --id argument as many times as you like. Each one is treated independently.
Thus the following example specifies all sensors for four combinations of visit and raft,
plus all sensors for one raft of two other visits:
- <code>--id visit=54123^55523 raft=1,1^2,1 --id visit=623459^293423 raft=0,0</code>

\subsection pipeBase_argumentParser_argumentFiles Argument Files

You may specify long or repetitive command-line arguments in text files and reference those files using @@path.

The contents of the files are identical to the command line, except that long lines
must not have a \\ continuation character. For example if the file foo contains:
<pre>
    --id visit=54123^55523 raft=1,1^2,1
    --config someParam=someValue --configfile configOverrideFilePath
</pre>

you can then reference it with <code>@@foo</code> and mix that with other command-line arguments
(including <code>--id</code> and <code>--config</code>):
<pre>
myTask.py inputPath @@foo --config anotherParam=anotherValue --output outputPath
</pre>

\subsection pipeBase_argumentParser_configOverride Overriding Config

The argument parser automatically loads specific config override files based on
the camera name and its obs package. See \ref pipeBase_configOverrideFiles.

In addition, you can specify config override files on the command line using --configfile
and override some (but not all) config parameters by specifying values on the command line using --config.

Examples:
- <code>--config str1=foo str2="fancier string" int1=5 intList=2,4,-87 float1=1.53 floatList=3.14,-5.6e7</code>
- <code>--configfile %config.py # where %config.py contains root.strList = "first string", "second string"</code>

There are important limitations on using <code>--config</code>; use a config override file to get around these issues:
- You cannot specify values for items in registries
- You cannot specify values for lists of strings
- You cannot specify a subset of list; you must specify all values at once

\section pipeBase_environmentVariables Environment Variables

The command parser uses environment variables PIPE_INPUT_ROOT, PIPE_CALIB_ROOT, and PIPE_OUTPUT_ROOT,
if available, to make it easier to specify the input, calib and output data repositories.
Each environment variable is used as a root directory for relative paths and ignored for absolute paths.
The default value for each of these environment variables is the current working directory. For example:
- mytask cameraname foo # use $PIPE_INPUT_ROOT/foo as the input repository (or ./foo if $PIPE_INPUT_ROOT is undefined)
- mytask cameraname . # use $PIPE_INPUT_ROOT (= $PIPE_INPUT_ROOT/.) as the input repository
- mytask cameraname /a/b # use /a/b as the input repository ($PIPE_INPUT_ROOT is ignored for absolute paths)

\section pipeBase_configOverrideFiles Automatically Loaded Config Override Files

When a pipeline task is run, two camera-specific configuration overrides are loaded, if found;
first one for the obs package then one for the camera. (There are two because in some cases
an obs package may contain data for multiple cameras). These files may override configuration
parameters or even replace subtasks with camera-specific variants (e.g. for instrument
signature removal). The configuration override files are, in order:
- <em>obs_path</em>/config/<em>task_name</em>.py
- <em>obs_path</em>/config/<em>camera_name</em>/<em>task_name</em>.py

where the path elements are:
- <em>task_name</em>: the name of the pipeline task, e.g. "processCcd"
- <em>camera_name</em>: the name of the camera, e.g. "lsstSim"
- <em>obs_path</em>: the path to the obs package for the camera, e.g. "obs_lsstSim"
*/
}}}
