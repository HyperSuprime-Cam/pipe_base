/**
\mainpage lsst::pipe::base; Base package for pipeline tasks

\section pipeBase_introduction Introduction

Infrastructure to support pipeline tasks

The basic design is as follows:
- Data is processed by a pipeline task, which is usually a subclass of CmdLineTask.
  This is done by calling the parseAndRun method of the task, which parses command-line arguments
  and executes the parsed command. parseAndRun also persists the configuration used for the task,
  and metadata generated by the task (including timing data) in most cases (not all tasks support this).

- Each task may call subtasks (instances of Task or CmdLineTask) as it sees fit.
  Data is passed between a parent task and its subtasks by subroutine calls.

- Most tasks have a run method that performs the primary data processing.
  - The run method for a subclass of CmdLineTask typically receives a single butler data reference,
    but subtasks may use any arguments deemed appropriate.
  - Each task's run method should return a pipe_base Struct; this allows named access to returned data,
    which provides safer evolution than relying on the order of returned values.
  
- Some useful general tasks are found in the pipe_tasks package, in the python directory.
  Tasks meant to be run from the command line (subclasses of CmdLineTask) also have
  a short script in the bin directory.
  Package-specific tasks belong in the relevant package, e.g. ip_isr has an IsrTask.
  
- Pipeline tasks may process multiple data IDs in parallel, using the multiprocessing library.
  Support for this is built into the argument parser and the code that runs command-line tasks
  (lsst.pipe.base.TaskRunner).

pipe_base is written purely in Python. Contents include:
- lsst.pipe.base.CmdLineTask: base class for pipeline tasks that can be run from the command line.
- lsst.pipe.base.Task: base class for subtasks that are not meant to be run from the command line.
- lsst.pipe.base.Struct: object returned by the run method of a task.
- lsst.pipe.base.ArgumentParser: command line parser for pipeline tasks.
- lsst.pipe.base.timeMethod: decorator to log performance information about a Task method.
- lsst.pipe.base.TaskRunner: a class that runs command-line tasks, using multiprocessing when requested.
    This will work "as is" for most command-line tasks, but will need to be be subclassed for some.

\section pipeBase_argumentParser Argument Parser Hints

Command-line tasks support <code>--help</code>.

The first argument to a task must be the path to the input repository (or --help). For example:
- <code>myTask path/to/input --id...</code> # valid: input path is the first argument
- <code>myTask --id ... path/to/input</code> # INVALID: an option comes before the input path

To shorten input, calib and output paths see \ref pipeBase_environmentVariables.

Data is specified as <code>key=value</code> pairs for one of the data identifier arguments (typically
ending in "Id"; when there is only one, it will typically be called <code>--id</code>); for details
see \ref pipeBase_argumentParser_dataIDs .  If there is more than one data identifer argument, then the
data identifiers are by default handled independently.

You may show the config, subtasks and/or data using <code>--show</code>. By default --show quits
after printing the information, but <code>--show run</code> allows the task to run. For example:
- <code>--show config data tasks</code> shows the config, data and subtasks, and then quits.
- <code>--show tasks run</code> show the subtasks and then runs the task.

For long or repetitive command lines you may wish to specify some arguments in separate text files.
See \ref pipeBase_argumentParser_argumentFiles for details.

\subsection pipeBase_argumentParser_dataIDs Specifying Data IDs

The data identifier arguments are used to specify IDs for input and output data. The ID keys depend
on the camera and on the data product in question. For example for lsstSim, calibrated exposures
are identified by the following keys: <code>visit</code>, <code>filter</code>,
<code>raft</code> and <code>sensor</code> (and a given visit has exactly one filter).

Omit a key to specify all values of that key. For example:
- <code>--id visit=54123</code> specifies all rafts and sensors for visit 54123 (and all filters, but there is just one filter per visit).
- <code>--id visit=54123 raft=1,0</code> specifies all sensors for visit raft 1,0 of visit 54123

To specify multiple data IDs you may separate values with ^ (a character that does not have special meaning to
the unix command parser). The result is the outer product (all possible combinations). For example:
- <code>--id visit=54123^55523 raft=1,1^2,1</code> specifies four IDs: visits 54123 and 55523 of rafts 1,1 and 2,1

By default (but depending on the application), you may specify a data identifier argument
as many times as you like. Each one is treated independently.
Thus the following example specifies all sensors for four combinations of visit and raft,
plus all sensors for one raft of two other visits:
- <code>--id visit=54123^55523 raft=1,1^2,1 --id visit=623459^293423 raft=0,0</code>

\subsection pipeBase_argumentParser_argumentFiles Argument Files

You may specify long or repetitive command-line arguments in text files and reference those files using @@path.

The contents of the files are identical to the command line, except that long lines
must not have a \\ continuation character. For example if the file <code>foo</code> contains:
<pre>
    --id visit=54123^55523 raft=1,1^2,1
    --config someParam=someValue --configfile configOverrideFilePath
</pre>

you can then reference it with <code>@@foo</code> and mix that with other command-line arguments
(including <code>--id</code> and <code>--config</code>):
<pre>
myTask.py inputPath @@foo --config anotherParam=anotherValue --output outputPath
</pre>

\subsection pipeBase_argumentParser_configOverride Overriding Config

The argument parser automatically loads specific config override files based on
the camera name and its obs package. See \ref pipeBase_configOverrideFiles.

In addition, you can specify config override files on the command line using --configfile
and override some (but not all) config parameters by specifying values on the command line using --config.

Examples:
- <code>--config str1=foo str2="fancier string" int1=5 intList=2,4,-87 float1=1.53 floatList=3.14,-5.6e7</code>
- <code>--configfile %config.py # where %config.py contains root.strList = "first string", "second string"</code>

There are important limitations on using <code>--config</code>; use a config override file to get around these issues:
- For items in registries you can only specify values for the active (current) item
- You cannot specify values for lists of strings
- You cannot specify a subset of list; you must specify all values at once

\section pipeBase_environmentVariables Environment Variables

The command parser uses environment variables PIPE_INPUT_ROOT, PIPE_CALIB_ROOT, and PIPE_OUTPUT_ROOT,
if available, to make it easier to specify the input, calib and output data repositories.
Each environment variable is used as a root directory for relative paths and ignored for absolute paths.
The default value for each of these environment variables is the current working directory. For example:
- mytask cameraname foo # use $PIPE_INPUT_ROOT/foo as the input repository (or ./foo if $PIPE_INPUT_ROOT is undefined)
- mytask cameraname . # use $PIPE_INPUT_ROOT (= $PIPE_INPUT_ROOT/.) as the input repository
- mytask cameraname /a/b # use /a/b as the input repository ($PIPE_INPUT_ROOT is ignored for absolute paths)

\section pipeBase_configOverrideFiles Automatically Loaded Config Override Files

When a pipeline task is run, two camera-specific configuration overrides are loaded, if found;
first one for the obs package then one for the camera. (There are two because in some cases
an obs package may contain data for multiple cameras). These files may override configuration
parameters or even replace subtasks with camera-specific variants (e.g. for instrument
signature removal). The configuration override files are, in order:
- <em>obs_path</em>/config/<em>task_name</em>.py
- <em>obs_path</em>/config/<em>camera_name</em>/<em>task_name</em>.py

where the path elements are:
- <em>task_name</em>: the name of the pipeline task, e.g. "processCcd"
- <em>camera_name</em>: the name of the camera, e.g. "lsstSim"
- <em>obs_path</em>: the path to the obs package for the camera, e.g. "obs_lsstSim"
*/
}}}
