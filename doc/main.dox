/**
\mainpage lsst::pipe::base; Base package for pipeline tasks

\section pipeBase_introduction Introduction

Infrastructure to support pipeline tasks

The basic design is as follows:
- Data is processed by a pipeline task, which is usually a subclass of CmdLineTask.
  This is done by calling the parseAndRun method of the task, which parses command-line arguments
  and executes the parsed command. parseAndRun also persists the configuration used for the task,
  and metadata generated by the task (including timing data).
  
- Pipeline tasks rarely, if ever, perform multitasking (though they may well use GPUs).
  For multitasking, run multiple instances of the task.

- Each task may call subtasks (instances of Task or CmdLineTask) as it sees fit.
  Data is passed between a parent task and its subtasks by subroutine calls.

- Most tasks have a run method that performs the primary data processing.
  The run method for a subclass of CmdLineTask typically receives a single butler data reference,
  but subtasks may use any arguments they wish. Each task's run method returns a pipe_base Struct;
  this allows named access to returned data, which provides safer evolution
  than relying on the order of returned values.
  
- Some useful general tasks are found in the pipe_tasks package, in the python directory.
  Tasks meant to be run from the command line (subclasses of CmdLineTask) also have
  a short script in the bin directory.
  Package-specific tasks belong in the relevant package, e.g. ip_isr has an IsrTask.

pipe_base is written purely in Python. Contents include:
- lsst.pipe.base.CmdLineTask: base class for pipeline tasks that can be run from the command line.
- lsst.pipe.base.Task: base class for subtasks that are not meant to be run from the command line.
- lsst.pipe.base.Struct: object returned by the run method of a task.
- lsst.pipe.base.ArgumentParser: command line parser for pipeline tasks.
- lsst.pipe.base.timeMethod: decorator to log performance information about a Task method.

\section pipeBase_configOverrideFiles Config Override Files

When a pipeline task is run, two camera-specific configuration overrides are loaded, if found;
first one for the obs package then one for the camera. (There are two because in some cases
an obs package may contain data for multiple cameras). These files may override configuration
parameters or even replace subtasks with camera-specific variants (e.g. for instrument
signature removal). The configuration override files are, in order:
- <em>obs_path</em>/config/<em>task_name</em>.py
- <em>obs_path</em>/config/<em>camera_name</em>/<em>task_name</em>.py

where the path elements are:
- <em>task_name</em>: the name of the pipeline task, e.g. "processCcd"
- <em>camera_name</em>: the name of the camera, e.g. "lsstSim"
- <em>obs_path</em>: the path to the obs package for the camera, e.g. "obs_lsstSim"

\section pipeBase_environmentVariables Environment Variables

The command parser uses environment variables PIPE_INPUT_ROOT, PIPE_CALIB_ROOT, and PIPE_OUTPUT_ROOT,
if available, to make it easier to specify the input, calib and output data repositories.
Each environment variable is used as a root directory for relative paths and ignored for absolute paths.
The default value for each of these environment variables is the current working directory. For example:
- mytask cameraname foo # use $PIPE_INPUT_ROOT/foo as the input repository (or ./foo if $PIPE_INPUT_ROOT is undefined)
- mytask cameraname . # use $PIPE_INPUT_ROOT (= $PIPE_INPUT_ROOT/.) as the input repository
- mytask cameraname /a/b # use /a/b as the input repository ($PIPE_INPUT_ROOT is ignored for absolute paths)
*/
}}}
